# Enigma Decryptor (Python) — README

> ⚠️ **Note:** This entire project (code and README) was generated by **GPT‑5**.
> The only manual modification was adding a small `if __name__ == "__main__"` execution block and some few details in the README

---

A didactic Python implementation to **encrypt/decrypt Enigma messages** and to **attack Enigma ciphertexts** under conditions close to what Allied cryptanalysts faced—except we leverage today’s computing power and simple language scoring.

> This is **not** a historical Bombe simulation. It’s a modern heuristic attacker (crib search + n-gram scoring + hill-climbing for the plugboard) that works on typical test messages.

---

## Features

* **Faithful Enigma M3 model** (Army/Air Force): rotors I–V, reflectors B/C

  * Correct stepping incl. **double-stepping**
  * Ring settings (Ringstellung), start positions (Grundstellung)
  * **Plugboard (Steckerbrett)** with up to 10 pairs
* **Encrypt/Decrypt** with the same routine (Enigma is symmetric)
* **Crib-based key search** (fast when you know a likely plaintext fragment)
* **Allied-style attack** with minimal prior info:

  * Seed search over rotor orders/positions
  * Ring refinement (search over 26³ ring settings)
  * **Hill-climbing plugboard** (up to 10 pairs)
* **Language scoring** (n-grams + common words)

  * German templates included (bigrams, trigrams, words)

No external dependencies (pure Python 3).

---

## Quick Start

### 1) Encrypt / Decrypt

```python
from your_module import Enigma  # adjust the import to your file name

# Same settings for encryption and decryption
cfg = dict(rotor_names=("I","II","III"), rings="AAA", pos="AAA",
           reflector="B", plug_pairs=None)

pt = "WETTERBERICHTVONBORD"

e1 = Enigma(**cfg)
ct = e1.enc(pt)

e2 = Enigma(**cfg)          # new instance or reset positions to decrypt
pt2 = e2.enc(ct)

print("CT:", ct)
print("PT:", pt2)           # equals original pt
```

> ⚠️ Don’t reuse the same `Enigma` instance to decrypt unless you **reset positions**: the rotors advance during encryption.

---

### 2) Break with a Crib (fast)

```python
from your_module import break_enigma_with_crib

ciphertext = "TMVXNWLTMFDSRIVOZGFCOELEEPDFLPNJEJLCQFKJTOXYDQJXHONBURFKC"
crib = "WETTER"

hits = break_enigma_with_crib(
    ciphertext,
    crib,
    rotor_orders=[("I","II","III")],  # narrow if you can
    rings="AAA",
    reflector="B",
    plugboard_pairs="PO ML IU KJ NH YT GB VF RE DC",
    search_positions=True
)

for h in hits:
    print(h["rotors"], h["ring"], h["pos"], h["reflector"])
    print("PLAINTEXT:", h["plaintext"])
```

---

### 3) “Allied-style” Attack (little prior info)

```python
from your_module import break_enigma_like_allies

result = break_enigma_like_allies(
    ciphertext="TMVXNWLTMFDSRIVOZGFCOELEEPDFLPNJEJLCQFKJTOXYDQJXHONBURFKC",
    rotor_set=("I","II","III","IV","V"),
    reflectors=("B","C"),
    pos_step=2,            # 1 = exhaustive; 2–3 = faster
    seed_keep=50,
    seed_sample_len=100,
    rings_keep=6,
    rings_sample_len=120,
    hill_iters=12000,      # increase for better quality (e.g., 50k–100k)
    hill_pairs=10,
    hill_sample_len=None,
    random_seed=1337,
    crib=None              # if you know a crib, set it here for a big speedup
)

print("ROTORS:", result["rotors"], "RINGS:", result["rings"],
      "POS:", result["pos"], "REFLECTOR:", result["reflector"])
print("PLUGBOARD:", " ".join(a+b for a,b in result["plugboard"]))
print("PLAINTEXT:", result["plaintext"])
```

---

## API Overview

### `class Enigma`

```python
Enigma(
  rotor_names=("I","II","III"),
  rings="AAA",        # Ringstellung
  pos="AAA",          # Grundstellung
  reflector="B",      # "B" or "C"
  plug_pairs=None     # list of pairs, e.g. [("A","B"), ("C","D")]
)
enc(text: str) -> str
```

### `break_enigma_with_crib(...)`

Brute-forces over rotor orders/positions (and optionally rings), checking if the **crib** appears in the decrypted text. Very fast when a crib is available.

### `break_enigma_like_allies(...)`

Three-phase heuristic attack (seed → rings → plugboard). Works without a crib; performs better with longer messages (≈100+ chars).

---

## Language Scoring

The attacker uses simple language heuristics. German sets are included by default.

**German bigrams/trigrams/words (example skeleton):**

```python
GER_BIGRAMS = "ER EN CH DE EI TE IN NG ND SC ST RE GE BE UN HE AN AU SE DI".split()
GER_TRIGRAMS = "DER DIE UND ICH NIC EIN SCH CHE DEN GEN UNS MIT END EIT".split()
GER_WORDS = """
DER DIE DAS UND IST NICHT EIN EINE MIT VON ZUR FUR WETTER BERICHT NORDSEE
BEFEHL UHR ANGRIFF SEKTOR MITTERNACHT UFER SICHERN UBOOT FEIND KONVOI
""".split()

def score_text(pt):
    pt = pt.upper()
    s = 0.0
    for bg in GER_BIGRAMS:  s += pt.count(bg)
    for tg in GER_TRIGRAMS: s += 2.0 * pt.count(tg)
    for w  in GER_WORDS:    s += 4.0 * min(pt.count(w), 3)
    return s
```

> For best results, normalize text to A–Z (strip umlauts: `Ä→AE`, `Ö→OE`, `Ü→UE`, `ß→SS`).

---

## Performance Tips

* **Crib search** is dramatically faster than blind search.
* Narrow what you can: rotor set, reflector, known pairs.
* Use messages **≥ 80–100 characters** for robust scoring.
* Increase `hill_iters` for plugboard quality; multiple random seeds can help.
* `pos_step=2` or `3` speeds up seed scans at a small cost in accuracy.

---

## Troubleshooting

* **Decrypting with the same object gives garbage:**
  You must **reset positions** (or create a new `Enigma` instance) before decryption; rotors stepped during encryption.
* **Short messages don’t decrypt well:**
  Use a crib or a longer ciphertext; scoring on very short texts is unreliable.
* **Wrong alphabet/characters:**
  Pre-clean text to A–Z only. Replace umlauts/accents (`Ä→AE`, `Ö→OE`, `Ü→UE`, `ß→SS`).

---

## What This Is / Isn’t

* ✅ Educational Enigma simulator and modern heuristic attacker
* ✅ Good for demonstrations, CTFs, coursework
* ❌ Not a historical Bombe emulation (no menu/loop wiring)
* ❌ Not optimized C/NumPy code; pure Python by design

---

## License

```
MIT License
Copyright (c) 2025 aghast10

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

---

## Acknowledgments

* Historical work by Rejewski, Zygalski, and Różycki (Polish Cipher Bureau)
* Alan Turing, Gordon Welchman, and the Bletchley Park teams
* Countless hobbyists and researchers who documented Enigma mechanics

---

## Appendix: Sample German Plaintext

A long, clean (A–Z) line that is neutral and useful for testing encryption/decryption quality:

```
DIE SONNE SCHEINT HEUTE AM HIMMEL UND DER VOGEL FLIEGT UBER DEN WALD MIT LEICHTEM WIND AUS NORDWESTEN (CRIB: SONNE)
```

Encrypt it with a secret configuration, then try to recover it with the attacker—just like a mini-Bletchley Park exercise.
